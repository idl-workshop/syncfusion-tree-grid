import * as events from '../../common/base/constant';
import * as cls from '../../common/base/css-constant';
import { Chart, ColumnSeries, LineSeries, Legend, Tooltip, Category, AreaSeries, StepLineSeries, SplineSeries, SplineAreaSeries, MultiColoredLineSeries, RangeAreaSeries, StackingAreaSeries, StepAreaSeries, MultiColoredAreaSeries, StackingColumnSeries, RangeColumnSeries, BarSeries, StackingBarSeries, ScatterSeries, BubbleSeries, PolarSeries, RadarSeries, MultiLevelLabel, ScrollBar, Zoom, ParetoSeries, Export, Crosshair } from '@syncfusion/ej2-charts';
import { createElement, remove } from '@syncfusion/ej2-base';
var PivotChart = /** @class */ (function () {
    function PivotChart() {
        this.headerColl = {};
        this.maxLevel = 0;
        this.columnGroupObject = {};
    }
    /**
     * Get component name.
     * @returns string
     * @private
     */
    PivotChart.prototype.getModuleName = function () {
        return 'pivotchart';
    };
    /* tslint:disable */
    PivotChart.prototype.loadChart = function (parent, chartSettings) {
        this.parent = parent;
        this.engineModule = this.parent.engineModule;
        this.dataSource = this.parent.dataSource;
        this.chartSettings = chartSettings;
        if (this.dataSource.values.length > 0) {
            if (this.chartSettings.enableMultiAxis) {
                this.measureList = this.dataSource.values.map(function (item) { return item.name; });
            }
            else {
                this.measureList = [chartSettings.value === '' ? this.dataSource.values[0].name : chartSettings.value];
            }
        }
        else if (this.parent.chart) {
            this.parent.chart.series = [];
            this.parent.chart.primaryXAxis.title = '';
            this.parent.chart.primaryYAxis.title = '';
            if (this.parent.chart.axes.length > 0) {
                this.parent.chart.axes[0].title = '';
            }
            this.parent.chart.primaryXAxis.zoomFactor = 1;
            this.parent.chart.refresh();
            return;
        }
        else {
            this.parent.notify(events.contentReady, {});
            return;
        }
        this.columnGroupObject = {};
        var pivotValues = this.parent.engineModule.pivotValues;
        this.currentMeasure = chartSettings.enableMultiAxis ? this.measureList[0] :
            (((chartSettings.value === '' || this.dataSource.values.filter(function (item) {
                return item.name === chartSettings.value;
            }).length === 0) && this.dataSource.values.length > 0) ? this.dataSource.values[0].name : chartSettings.value);
        var totColIndex = this.getColumnTotalIndex(pivotValues);
        var rKeys = Object.keys(pivotValues);
        var prevLevel;
        var indexCount = -0.5;
        this.headerColl = {};
        for (var _i = 0, rKeys_1 = rKeys; _i < rKeys_1.length; _i++) {
            var rKey = rKeys_1[_i];
            var rowIndex = Number(rKey);
            if (pivotValues[rowIndex][0] && pivotValues[rowIndex][0].axis === 'row' &&
                (this.dataSource.rows.length === 0 ? true : pivotValues[rowIndex][0].type !== 'grand sum')) {
                var firstRowCell = pivotValues[rowIndex][0];
                this.maxLevel = firstRowCell.level > this.maxLevel ? firstRowCell.level : this.maxLevel;
                if (!(prevLevel === undefined || prevLevel < firstRowCell.level)) {
                    indexCount++;
                }
                prevLevel = firstRowCell.level;
                var name_1 = firstRowCell.actualText ? firstRowCell.actualText.toString() : firstRowCell.formattedText.toString();
                var caption = firstRowCell.hasChild ? ((firstRowCell.isDrilled ? ' - ' : ' + ') + name_1) : name_1;
                var cellInfo = {
                    name: name_1,
                    text: caption,
                    levelName: firstRowCell.valueSort['levelName'].toString(),
                    level: firstRowCell.level,
                    fieldName: firstRowCell.valueSort['axis'] ? firstRowCell.valueSort['axis'].toString() : ''
                };
                if (this.headerColl[indexCount]) {
                    this.headerColl[indexCount][firstRowCell.level] = cellInfo;
                }
                else {
                    this.headerColl[indexCount] = {};
                    this.headerColl[indexCount][firstRowCell.level] = cellInfo;
                }
                var rows = pivotValues[rowIndex];
                var cKeys = Object.keys(rows);
                for (var _a = 0, cKeys_1 = cKeys; _a < cKeys_1.length; _a++) {
                    var cKey = cKeys_1[_a];
                    var cellIndex = Number(cKey);
                    var cell = pivotValues[rowIndex][cellIndex];
                    if (!totColIndex[cell.colIndex] && cell.axis === 'value' &&
                        (chartSettings.enableMultiAxis ? true : cell.actualText === this.currentMeasure)) {
                        if (firstRowCell.members.length > 0) {
                            break;
                        }
                        var columnSeries = cell.columnHeaders.toString().split('.').join(' - ') + ' | ' + cell.actualText;
                        if (this.columnGroupObject[columnSeries]) {
                            this.columnGroupObject[columnSeries].push({
                                x: this.dataSource.rows.length === 0 ? firstRowCell.formattedText :
                                    cell.rowHeaders.toString().split('.').join(' - '),
                                y: Number(cell.value)
                            });
                        }
                        else {
                            this.columnGroupObject[columnSeries] = [{
                                    x: this.dataSource.rows.length === 0 ? firstRowCell.formattedText :
                                        cell.rowHeaders.toString().split('.').join(' - '),
                                    y: Number(cell.value)
                                }];
                        }
                    }
                }
            }
        }
        this.refreshChart();
    };
    /**
     * Refreshing chart based on the updated chartSettings.
     * @returns void
     */
    PivotChart.prototype.refreshChart = function () {
        this.chartSeries = [];
        var columnKeys = Object.keys(this.columnGroupObject);
        this.persistSettings = JSON.parse(this.parent.getPersistData()).chartSettings;
        for (var _i = 0, columnKeys_1 = columnKeys; _i < columnKeys_1.length; _i++) {
            var key = columnKeys_1[_i];
            var currentSeries = {};
            currentSeries = this.persistSettings.chartSeries ? this.frameObjectWithKeys(this.persistSettings.chartSeries) : currentSeries;
            currentSeries.dataSource = this.columnGroupObject[key];
            currentSeries.xName = 'x';
            currentSeries.yName = 'y';
            currentSeries.name = this.chartSettings.enableMultiAxis ? key : key.split(' | ')[0];
            if (!(this.chartSettings.chartSeries.type === 'Polar' || this.chartSettings.chartSeries.type === 'Radar')) {
                currentSeries.yAxisName = key.split(' | ')[1];
            }
            this.chartSeries = this.chartSeries.concat(currentSeries);
        }
        var seriesEvent = { series: this.chartSeries, cancel: false };
        this.parent.trigger(events.chartSeriesCreated, seriesEvent);
        if (!seriesEvent.cancel) {
            this.bindChart();
        }
        else {
            if (this.element) {
                remove(this.element);
            }
            this.parent.notify(events.contentReady, {});
        }
    };
    PivotChart.prototype.frameObjectWithKeys = function (series) {
        var keys = Object.keys(series);
        var keyPos = 0;
        var framedSeries = {};
        while (keyPos < keys.length) {
            framedSeries[keys[keyPos]] = series[keys[keyPos]];
            keyPos++;
        }
        return framedSeries;
    };
    PivotChart.prototype.bindChart = function () {
        var currentXAxis = this.configXAxis();
        var currentTooltipSettings = this.configTooltipSettings();
        var currentLegendSettings = this.configLegendSettings();
        var currentZoomSettings = this.configZoomSettings();
        var axesWithRows = this.frameAxesWithRows();
        var type = this.chartSettings.chartSeries.type;
        if (this.parent.displayOption.view === 'Both') {
            this.element = this.parent.displayOption.primary === 'Chart' ? (this.parent.element.insertBefore((!this.element ? (createElement('div', {
                className: cls.PIVOTCHART, id: this.parent.element.id + '_chart'
            })) : this.element), this.parent.element.querySelector('.' + cls.GRID_CLASS))) :
                (this.parent.element.appendChild(!this.element ? (createElement('div', {
                    className: cls.PIVOTCHART, id: this.parent.element.id + '_chart'
                })) : this.element));
        }
        else if (!this.element) {
            this.element = this.parent.element.appendChild(createElement('div', {
                className: cls.PIVOTCHART, id: this.parent.element.id + '_chart'
            }));
        }
        if (!this.parent.chart) {
            if (this.parent.showGroupingBar) {
                this.element.style.minWidth = '400px !important';
            }
            else {
                this.element.style.minWidth = '310px !important';
            }
            Chart.Inject(ColumnSeries, StackingColumnSeries, RangeColumnSeries, BarSeries, StackingBarSeries, ScatterSeries, BubbleSeries, LineSeries, StepLineSeries, SplineSeries, SplineAreaSeries, MultiColoredLineSeries, PolarSeries, RadarSeries, AreaSeries, RangeAreaSeries, StackingAreaSeries, StepAreaSeries, MultiColoredAreaSeries, ParetoSeries, Legend, Tooltip, Category, MultiLevelLabel, ScrollBar, Zoom, Export, Crosshair);
            this.parent.chart = new Chart({
                series: this.chartSeries,
                legendSettings: currentLegendSettings,
                tooltip: currentTooltipSettings,
                zoomSettings: currentZoomSettings,
                axes: (type === 'Polar' || type === 'Radar') ? [] : axesWithRows.axes,
                rows: (type === 'Polar' || type === 'Radar') ? [{}] : axesWithRows.rows,
                primaryYAxis: (type === 'Polar' || type === 'Radar') ? axesWithRows.axes[0] : { visible: false },
                primaryXAxis: currentXAxis,
                width: this.parent.width.toString(),
                height: this.parent.height.toString(),
                title: this.chartSettings.title,
                titleStyle: this.chartSettings.titleStyle,
                subTitle: this.chartSettings.subTitle,
                subTitleStyle: this.chartSettings.subTitleStyle,
                margin: this.chartSettings.margin,
                border: this.chartSettings.border,
                background: this.chartSettings.background,
                chartArea: this.chartSettings.chartArea,
                palettes: this.chartSettings.palettes,
                theme: this.chartSettings.theme,
                crosshair: this.chartSettings.crosshair,
                selectionMode: this.chartSettings.selectionMode,
                isMultiSelect: this.chartSettings.isMultiSelect,
                enableExport: this.chartSettings.enableExport,
                selectedDataIndexes: this.chartSettings.selectedDataIndexes,
                isTransposed: this.chartSettings.isTransposed,
                enableAnimation: this.chartSettings.enableAnimation,
                description: this.chartSettings.description,
                tabIndex: this.chartSettings.tabIndex,
                locale: this.parent.locale,
                enableSideBySidePlacement: this.chartSettings.enableSideBySidePlacement,
                beforePrint: this.chartSettings.beforePrint ? this.chartSettings.beforePrint.bind(this) : undefined,
                animationComplete: this.chartSettings.animationComplete ? this.chartSettings.animationComplete.bind(this) : undefined,
                legendRender: this.chartSettings.legendRender ? this.chartSettings.legendRender.bind(this) : undefined,
                textRender: this.chartSettings.textRender ? this.chartSettings.textRender.bind(this) : undefined,
                pointRender: this.chartSettings.pointRender ? this.chartSettings.pointRender.bind(this) : undefined,
                seriesRender: this.chartSettings.seriesRender ? this.chartSettings.seriesRender.bind(this) : undefined,
                chartMouseMove: this.chartSettings.chartMouseMove ? this.chartSettings.chartMouseMove.bind(this) : undefined,
                chartMouseClick: this.chartSettings.chartMouseClick ? this.chartSettings.chartMouseClick.bind(this) : undefined,
                pointMove: this.chartSettings.pointMove ? this.chartSettings.pointMove.bind(this) : undefined,
                pointClick: this.chartSettings.pointClick ? this.chartSettings.pointClick.bind(this) : undefined,
                chartMouseLeave: this.chartSettings.chartMouseLeave ? this.chartSettings.chartMouseLeave.bind(this) : undefined,
                chartMouseDown: this.chartSettings.chartMouseDown ? this.chartSettings.chartMouseDown.bind(this) : undefined,
                chartMouseUp: this.chartSettings.chartMouseUp ? this.chartSettings.chartMouseUp.bind(this) : undefined,
                dragComplete: this.chartSettings.dragComplete ? this.chartSettings.dragComplete.bind(this) : undefined,
                zoomComplete: this.chartSettings.zoomComplete ? this.chartSettings.zoomComplete.bind(this) : undefined,
                scrollStart: this.chartSettings.scrollStart ? this.chartSettings.scrollStart.bind(this) : undefined,
                scrollEnd: this.chartSettings.scrollEnd ? this.chartSettings.scrollEnd.bind(this) : undefined,
                scrollChanged: this.chartSettings.scrollChanged ? this.chartSettings.scrollChanged.bind(this) : undefined,
                tooltipRender: this.tooltipRender.bind(this),
                loaded: this.loaded.bind(this),
                load: this.load.bind(this),
                resized: this.resized.bind(this),
                axisLabelRender: this.axisLabelRender.bind(this)
            }, '#' + this.parent.element.id + '_chart');
        }
        else {
            this.parent.chart.series = this.chartSeries;
            this.parent.chart.primaryXAxis = currentXAxis;
            if (type === 'Polar' || type === 'Radar') {
                this.parent.chart.primaryYAxis.visible = true;
                this.parent.chart.primaryYAxis = axesWithRows.axes[0];
                this.parent.chart.axes = [];
                this.parent.chart.rows = [{}];
            }
            else {
                this.parent.chart.primaryYAxis.visible = false;
                this.parent.chart.axes = axesWithRows.axes;
                this.parent.chart.rows = axesWithRows.rows;
            }
            this.parent.chart.refresh();
        }
    };
    PivotChart.prototype.frameAxesWithRows = function () {
        var _this = this;
        var axes = [];
        var rows = [];
        var percentChart = this.persistSettings.chartSeries && (this.persistSettings.chartSeries.type === 'StackingColumn100' ||
            this.persistSettings.chartSeries.type === 'StackingBar100' ||
            this.persistSettings.chartSeries.type === 'StackingArea100');
        if (this.chartSettings.enableMultiAxis) {
            var valCnt = 0;
            var divider = (100 / this.dataSource.values.length) + '%';
            var _loop_1 = function (item) {
                var measureField = this_1.engineModule.fieldList[item.name];
                var measureAggregatedName = this_1.parent.localeObj.getConstant(measureField.aggregateType) + ' of ' + measureField.caption;
                var formatSetting = this_1.dataSource.formatSettings.filter(function (itm) {
                    return itm.name === item.name;
                })[0];
                var resFormat = (this_1.chartSettings.chartSeries.type === 'Polar' || this_1.chartSettings.chartSeries.type === 'Radar') ? true : false;
                var currentYAxis = {};
                currentYAxis = this_1.persistSettings.primaryYAxis ?
                    this_1.frameObjectWithKeys(this_1.persistSettings.primaryYAxis) : currentYAxis;
                currentYAxis.labelFormat = currentYAxis.labelFormat ?
                    currentYAxis.labelFormat : (percentChart ? '' : (formatSetting && !resFormat ? formatSetting.format : 'N'));
                currentYAxis.title = currentYAxis.title ? currentYAxis.title : measureAggregatedName;
                currentYAxis.plotOffset = currentYAxis.plotOffset ? currentYAxis.plotOffset : (valCnt % 2 !== 0 ? 30 : 0);
                currentYAxis.rowIndex = valCnt;
                if (!resFormat) {
                    currentYAxis.name = item.name;
                }
                axes = axes.concat(currentYAxis);
                rows.push({ height: divider });
                valCnt++;
            };
            var this_1 = this;
            for (var _i = 0, _a = this.dataSource.values; _i < _a.length; _i++) {
                var item = _a[_i];
                _loop_1(item);
            }
        }
        else {
            var measureField = this.engineModule.fieldList[this.currentMeasure];
            var measureAggregatedName = this.parent.localeObj.getConstant(measureField.aggregateType) + ' of ' +
                measureField.caption;
            var formatSetting = this.dataSource.formatSettings.filter(function (item) {
                return item.name === _this.currentMeasure;
            })[0];
            var currentYAxis = {};
            currentYAxis = this.persistSettings.primaryYAxis ? this.frameObjectWithKeys(this.persistSettings.primaryYAxis) : currentYAxis;
            currentYAxis.rowIndex = 0;
            if (!(this.chartSettings.chartSeries.type === 'Polar' || this.chartSettings.chartSeries.type === 'Radar')) {
                currentYAxis.name = this.currentMeasure;
            }
            currentYAxis.labelFormat = currentYAxis.labelFormat ? currentYAxis.labelFormat : (percentChart ? '' : (formatSetting ?
                formatSetting.format : 'N'));
            currentYAxis.title = currentYAxis.title ? currentYAxis.title : measureAggregatedName;
            axes = axes.concat(currentYAxis);
            rows.push({ height: '100%' });
        }
        return { axes: axes, rows: rows };
    };
    PivotChart.prototype.getColumnTotalIndex = function (pivotValues) {
        var colIndexColl = {};
        var rKeys = Object.keys(pivotValues);
        for (var _i = 0, rKeys_2 = rKeys; _i < rKeys_2.length; _i++) {
            var rowIndex = rKeys_2[_i];
            var rows = pivotValues[Number(rowIndex)];
            var cKeys = Object.keys(rows);
            for (var _a = 0, cKeys_2 = cKeys; _a < cKeys_2.length; _a++) {
                var cellIndex = cKeys_2[_a];
                var cell = rows[Number(cellIndex)];
                if (cell.axis !== 'column') {
                    return colIndexColl;
                }
                else if ((cell.type === 'sum' || (this.dataSource.columns.length === 0 ? false : cell.type === 'grand sum'))
                    && cell.rowSpan !== -1) {
                    colIndexColl[cell.colIndex] = cell.colIndex;
                }
            }
        }
        return colIndexColl;
    };
    // The commented lines will be utilized once we get the requested requirement(of multi-level labels) from chart team.
    // private frameMultiLevelLabels(): MultiLevelLabelsModel[] {
    //     let startKeys: string[] = Object.keys(this.headerColl);
    //     let parentHeaders: RowHeaderLevelGrouping = this.headerColl[-0.5];
    //     for (let startKey of startKeys) {
    //         let sKey: number = Number(startKey);
    //         let headers = this.headerColl[sKey];
    //         let levelPos: number = 0;
    //         let isAvail: boolean = false;
    //         while (levelPos <= this.maxLevel) {
    //             if (!isAvail) {
    //                 if (!headers[levelPos]) {
    //                     headers[levelPos] = parentHeaders[levelPos];
    //                 } else {
    //                     isAvail = true;
    //                 }
    //             } else if (!headers[levelPos]) {
    //                 headers[levelPos] = {
    //                     name: headers[levelPos - 1].name,
    //                     text: headers[levelPos - 1].text,
    //                     levelName: headers[levelPos - 1].levelName,
    //                     level: headers[levelPos - 1].level,
    //                     fieldName: headers[levelPos - 1].fieldName,
    //                     span: -1
    //                 };
    //                 headers[levelPos - 1].span = 0;
    //             }
    //             levelPos++;
    //         }
    //         parentHeaders = this.headerColl[sKey];
    //     }
    //     let gRows: { [key: number]: any } = {};
    //     for (let startKey of startKeys) {
    //         let sKey: number = Number(startKey);
    //         let headers = this.headerColl[sKey];
    //         let lKeys: string[] = Object.keys(headers);
    //         for (let levelKey of lKeys) {
    //             let lKey: number = Number(levelKey);
    //             if (gRows[lKey]) {
    //                 let len: number = gRows[lKey].length;
    //                 if (headers[lKey].levelName === parentHeaders[lKey].levelName) {
    //                     gRows[lKey][len - 1].end = gRows[lKey][len - 1].end as number + 1;
    //                 } else {
    //                     gRows[lKey].push({ start: sKey, end: sKey + 1, text: headers[lKey].text, customAttributes: headers[lKey] });
    //                 }
    //             } else {
    //                 gRows[lKey] = [{ start: sKey, end: sKey + 1, text: headers[lKey].text, customAttributes: headers[lKey] }];
    //             }
    //         }
    //         parentHeaders = headers;
    //     }
    //     let levellength: number = Object.keys(gRows).length;
    //     let multiLevelLabels: MultiLevelLabelsModel[] = [];
    //     for (let level: number = levellength - 1; level > -1; level--) {
    //         multiLevelLabels.push({ categories: gRows[level] });
    //     }
    //     return multiLevelLabels;
    // }
    PivotChart.prototype.getZoomFactor = function () {
        if (!isNaN(Number(this.parent.width))) {
            this.calculatedWidth = Number(this.parent.width);
        }
        else if (this.parent.width.indexOf('%') > -1) {
            this.calculatedWidth = this.parent.element.clientWidth * (parseFloat(this.parent.width) / 100);
        }
        else if (this.parent.width.indexOf('px') > -1) {
            this.calculatedWidth = Number(this.parent.width.toString().split('px')[0]);
        }
        else {
            this.calculatedWidth = this.parent.element.clientWidth;
        }
        var seriesLength = (this.chartSeries.length * 10) > 120 ? (this.chartSeries.length * 10) : 120;
        var zoomFactor = this.chartSeries.length > 0 ?
            (this.calculatedWidth / (Object.keys(this.chartSeries[0].dataSource).length * seriesLength)) : 1;
        zoomFactor = (zoomFactor < 1 && zoomFactor > 0) ? zoomFactor : 1;
        return zoomFactor;
    };
    PivotChart.prototype.configTooltipSettings = function () {
        var tooltip = this.chartSettings.tooltip;
        tooltip.enable = tooltip.enable === undefined ? true : tooltip.enable;
        tooltip.header = tooltip.header ? tooltip.header : '';
        tooltip.enableMarker = tooltip.enableMarker === undefined ? true : tooltip.enableMarker;
        return tooltip;
    };
    PivotChart.prototype.configLegendSettings = function () {
        var legendSettings = {};
        legendSettings = this.chartSettings.legendSettings ? this.chartSettings.legendSettings : legendSettings;
        legendSettings.padding = legendSettings.padding ? legendSettings.padding : 25;
        legendSettings.shapePadding = legendSettings.shapePadding ? legendSettings.shapePadding : 10;
        return legendSettings;
    };
    PivotChart.prototype.configXAxis = function () {
        var currentXAxis = {};
        currentXAxis = this.persistSettings.primaryXAxis ? this.frameObjectWithKeys(this.persistSettings.primaryXAxis) : currentXAxis;
        currentXAxis.valueType = 'Category';
        currentXAxis.labelIntersectAction = currentXAxis.labelIntersectAction ? currentXAxis.labelIntersectAction : 'Rotate45';
        currentXAxis.title = currentXAxis.title ? currentXAxis.title :
            this.dataSource.rows.map(function (args) { return args.caption || args.name; }).join(' / ');
        currentXAxis.zoomFactor = this.getZoomFactor();
        return currentXAxis;
    };
    PivotChart.prototype.configZoomSettings = function () {
        var zoomSettings = this.chartSettings.zoomSettings;
        zoomSettings.enableSelectionZooming = zoomSettings.enableSelectionZooming === undefined ? true : zoomSettings.enableSelectionZooming;
        zoomSettings.enableScrollbar = zoomSettings.enableScrollbar === undefined ? true : zoomSettings.enableScrollbar;
        return zoomSettings;
    };
    PivotChart.prototype.tooltipRender = function (args) {
        var measureField = this.engineModule.fieldList[args.series.yAxisName ? (args.series.yAxisName.split('_CumulativeAxis')[0]) :
            (this.chartSettings.enableMultiAxis ? args.series.name.split(' | ')[1] : this.currentMeasure)];
        var measureAggregatedName = this.parent.localeObj.getConstant(measureField.aggregateType) + ' of ' + measureField.caption;
        args.text = measureAggregatedName + ': ' + this.parent.engineModule.getFormattedValue(args.point.y, measureField.id).formattedText + ' <br/>' +
            (this.dataSource.columns.length === 0 ? '' :
                this.parent.localeObj.getConstant('column') + ': ' + args.series.name.split(' | ')[0] + ' <br/>') +
            (this.dataSource.rows.length === 0 ? '' :
                this.parent.localeObj.getConstant('row') + ': ' + args.point.x);
        this.parent.trigger(events.chartTooltipRender, args);
    };
    // The commented lines will be utilized once we get the requested requirement(of multi-level labels) from chart team.
    PivotChart.prototype.loaded = function (args) {
        this.parent.isChartLoaded = true;
        if (this.parent.chart && this.parent.showGroupingBar && this.parent.groupingBarModule &&
            this.parent.showFieldList && this.parent.currentView === 'Chart') {
            this.parent.groupingBarModule.alignIcon();
        }
        // if (this.chartSettings.showMultiLevelLabels) {
        //     this.parent.element.querySelector(
        //         "#" + this.parent.element.id + "_chartXAxisMultiLevelLabel0").setAttribute('cursor', 'pointer');
        // }
        this.parent.notify(events.contentReady, {});
        this.parent.trigger(events.chartLoaded, args);
    };
    // The commented lines will be utilized once we get the requested requirement(of multi-level labels) from chart team.
    PivotChart.prototype.axisLabelRender = function (args) {
        // if (this.chartSettings.showMultiLevelLabels) {
        //     if (args.axis.name === 'primaryXAxis') {
        //         args.text = '';
        //     }
        // }
        this.parent.trigger(events.chartAxisLabelRender, args);
    };
    PivotChart.prototype.load = function (args) {
        if (args.chart.zoomModule) {
            args.chart.zoomModule.isZoomed = true;
        }
        this.parent.trigger(events.chartLoad, args);
    };
    PivotChart.prototype.resized = function (args) {
        args.chart.primaryXAxis.zoomFactor = this.getZoomFactor();
        this.parent.trigger(events.chartResized, args);
    };
    /**
     * To destroy the chart module
     * @returns void
     * @hidden
     */
    /* tslint:disable:no-empty */
    PivotChart.prototype.destroy = function () {
    };
    return PivotChart;
}());
export { PivotChart };
