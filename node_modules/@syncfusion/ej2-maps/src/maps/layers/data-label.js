import { findMidPointOfPolygon, Rect, filter, getTemplateFunction, getTranslate, RectOption, convertElementFromLabel, Point, TextOption, renderTextElement, textTrim, measureText, Internalize } from '../utils/helper';
import { isNullOrUndefined } from '@syncfusion/ej2-base';
import { dataLabelRendering } from '../model/constants';
/**
 * DataLabel Module used to render the maps datalabel
 */
var DataLabel = /** @class */ (function () {
    function DataLabel(maps) {
        this.value = { rightWidth: 0, leftWidth: 0, heightTop: 0, heightBottom: 0 };
        this.maps = maps;
        this.dataLabelCollections = [];
    }
    //tslint:disable:max-func-body-length
    DataLabel.prototype.getDataLabel = function (dataSource, labelPath, shapeName, shapeDataPath) {
        var text;
        for (var i = 0; i < dataSource.length; i++) {
            var data = dataSource[i];
            if ((data[shapeDataPath]) === shapeName) {
                text = data;
                break;
            }
        }
        return text;
    };
    /**
     * To render label for maps
     * @param layer
     * @param layerIndex
     * @param shape
     * @param layerData
     * @param group
     * @param labelTemplateElement
     * @param index
     */
    DataLabel.prototype.renderLabel = function (layer, layerIndex, shape, layerData, group, labelTemplateElement, index, intersect) {
        var dataLabel = layer.dataLabelSettings;
        var style = layer.dataLabelSettings.textStyle;
        var markerEle;
        var templateFn;
        var options;
        var dataLabelSettings = layer.dataLabelSettings;
        var labelpath = layer.dataLabelSettings.labelPath;
        var shapePoint = [[]];
        var midIndex = 0;
        var pointsLength = 0;
        var shapeData = shape;
        var element;
        var data;
        var text = '';
        var datasrcObj;
        var currentLength = 0;
        var location;
        var shapeProperties = shape['properties'];
        var labelId = this.maps.element.id + '_LayerIndex_' + layerIndex + '_shapeIndex_' + index + '_LabelIndex_' + index;
        var textLocation = new Point(0, 0);
        /* tslint:disable:no-string-literal */
        var shapes = layerData[index];
        style.fontFamily = this.maps.theme === 'Bootstrap4' ? 'HelveticaNeue-Medium' : style.fontFamily;
        shape = shapes['property'];
        var properties = (Object.prototype.toString.call(layer.shapePropertyPath) === '[object Array]' ?
            layer.shapePropertyPath : [layer.shapePropertyPath]);
        var propertyPath;
        for (var j = 0; j < properties.length; j++) {
            if (shapeProperties[properties[j]]) {
                propertyPath = properties[j];
                break;
            }
        }
        datasrcObj = this.getDataLabel(layer.dataSource, labelpath, shapeData['properties'][propertyPath], layer.shapeDataPath);
        if (!isNullOrUndefined(shapes['property']) && ((shapeProperties[labelpath]) || datasrcObj)) {
            shapePoint = [[]];
            if (!layerData[index]['_isMultiPolygon']) {
                shapePoint.push(this.getPoint(layerData[index], []));
                currentLength = shapePoint[shapePoint.length - 1].length;
                if (pointsLength < currentLength) {
                    pointsLength = currentLength;
                    midIndex = shapePoint.length - 1;
                }
            }
            else {
                var layer_1 = layerData[index];
                for (var j = 0; j < layer_1.length; j++) {
                    shapePoint.push(this.getPoint(layer_1[j], []));
                    currentLength = shapePoint[shapePoint.length - 1].length;
                    if (pointsLength < currentLength) {
                        pointsLength = currentLength;
                        midIndex = shapePoint.length - 1;
                    }
                }
            }
        }
        text = (!isNullOrUndefined(datasrcObj)) ? datasrcObj[labelpath].toString() : shapeData['properties'][labelpath];
        var projectionType = this.maps.projectionType;
        location = findMidPointOfPolygon(shapePoint[midIndex], projectionType);
        if (!isNullOrUndefined(text) && !isNullOrUndefined(location)) {
            location['y'] = (this.maps.projectionType === 'Mercator') ? location['y'] : (-location['y']);
            data = location;
            if (!isNullOrUndefined(this.maps.format) && !isNaN(parseFloat(text))) {
                if (this.maps.useGroupingSeparator) {
                    text = Internalize(this.maps, parseFloat(text));
                    if (!isNullOrUndefined(datasrcObj)) {
                        datasrcObj[labelpath] = text;
                    }
                }
            }
            var eventargs = {
                name: dataLabelRendering, maps: this.maps, cancel: false, border: dataLabel.border, datalabel: dataLabel,
                fill: dataLabel.fill, template: dataLabel.template, text: text
            };
            this.maps.trigger(dataLabelRendering, eventargs);
            var border = { color: 'yellow' };
            var position = [];
            var width = location['rightMax']['x'] - location['leftMax']['x'];
            if (!isNullOrUndefined(this.maps.dataLabelShape)) {
                this.maps.dataLabelShape.push(width);
            }
            var textSize = measureText(text, style);
            var trimmedLable = textTrim(width, text, style);
            var elementSize = measureText(trimmedLable, style);
            var startY = location['y'] - textSize['height'] / 4;
            var endY = location['y'] + textSize['height'] / 4;
            var start = location['y'] - textSize['height'] / 4;
            var end = location['y'] + textSize['height'] / 4;
            position = filter(shapePoint[midIndex], startY, endY);
            if (position.length > 5 && (shapeData['geometry']['type'] !== 'MultiPolygon') &&
                (shapeData['type'] !== 'MultiPolygon')) {
                var location1 = findMidPointOfPolygon(position, projectionType);
                location['x'] = location1['x'];
                width = location1['rightMax']['x'] - location1['leftMax']['x'];
            }
            var xpositionEnds = location['x'] + textSize['width'] / 2;
            var xpositionStart = location['x'] - textSize['width'] / 2;
            trimmedLable = textTrim(width, text, style);
            elementSize = measureText(trimmedLable, style);
            this.value[index] = { rightWidth: xpositionEnds, leftWidth: xpositionStart, heightTop: start, heightBottom: end };
            var animate = layer.animationDuration !== 0 || isNullOrUndefined(this.maps.zoomModule);
            var translate = (this.maps.isTileMap) ? new Object() : getTranslate(this.maps, layer, animate);
            var scale = (this.maps.isTileMap) ? this.maps.scale : translate['scale'];
            var transPoint = (this.maps.isTileMap) ? this.maps.translatePoint : translate['location'];
            var labelElement = void 0;
            if (eventargs.template !== '') {
                templateFn = getTemplateFunction(eventargs.template);
                var templateElement = templateFn(this.maps);
                labelElement = convertElementFromLabel(templateElement, labelId, !isNullOrUndefined(datasrcObj) ? datasrcObj : shapeData['properties'], index, this.maps);
                labelElement.style.left = ((Math.abs(this.maps.baseMapRectBounds['min']['x'] - location['x'])) * scale) + 'px';
                labelElement.style.top = ((Math.abs(this.maps.baseMapRectBounds['min']['y'] - location['y'])) * scale) + 'px';
                labelTemplateElement.appendChild(labelElement);
                var labelWidth = labelElement.offsetWidth;
                var labelHeight = labelElement.offsetHeight;
            }
            else {
                if (dataLabelSettings.smartLabelMode === 'Trim') {
                    options = new TextOption(labelId, textLocation.x, textLocation.y, 'middle', trimmedLable, '', '');
                }
                if (dataLabelSettings.smartLabelMode === 'None') {
                    options = new TextOption(labelId, (textLocation.x), textLocation.y, 'middle', text, '', '');
                }
                if (dataLabelSettings.smartLabelMode === 'Hide') {
                    text = (width >= textSize['width']) ? text : '';
                    options = new TextOption(labelId, (textLocation.x), (textLocation.y), 'middle', text, '', '');
                }
                text = options['text'];
                if (dataLabelSettings.intersectionAction === 'Hide' && this.maps.scale < 2) {
                    for (var i = 0; i < intersect.length; i++) {
                        if (!isNullOrUndefined(intersect[i])) {
                            if (this.value[index]['leftWidth'] > intersect[i]['rightWidth']
                                || this.value[index]['rightWidth'] < intersect[i]['leftWidth']
                                || this.value[index]['heightTop'] > intersect[i]['heightBottom']
                                || this.value[index]['heightBottom'] < intersect[i]['heightTop']) {
                                text = text;
                            }
                            else {
                                text = '';
                                break;
                            }
                        }
                    }
                    intersect.push(this.value[index]);
                    options = new TextOption(labelId, textLocation.x, textLocation.y, 'middle', text, '', '');
                }
                var difference = void 0;
                if (dataLabelSettings.intersectionAction === 'Trim') {
                    for (var j = 0; j < intersect.length; j++) {
                        if (!isNullOrUndefined(intersect[j])) {
                            if (intersect[j]['rightWidth'] < this.value[index]['leftWidth']
                                || intersect[j]['leftWidth'] > this.value[index]['rightWidth']
                                || intersect[j]['heightBottom'] < this.value[index]['heightTop']
                                || intersect[j]['heightTop'] > this.value[index]['heightBottom']) {
                                trimmedLable = text;
                                difference = 0;
                            }
                            else {
                                if (this.value[index]['leftWidth'] > intersect[j]['leftWidth']) {
                                    width = intersect[j]['rightWidth'] - this.value[index]['leftWidth'];
                                    difference = width - (this.value[index]['rightWidth'] - this.value[index]['leftWidth']);
                                    trimmedLable = textTrim(difference, text, style);
                                    break;
                                }
                                if (this.value[index]['leftWidth'] < intersect[j]['leftWidth']) {
                                    width = this.value[index]['rightWidth'] - intersect[j]['leftWidth'];
                                    difference = Math.abs(width - (this.value[index]['rightWidth'] - this.value[index]['leftWidth']));
                                    trimmedLable = textTrim(difference, text, style);
                                    break;
                                }
                            }
                        }
                    }
                    intersect.push(this.value[index]);
                    options = new TextOption(labelId, textLocation.x, (textLocation.y), 'middle', trimmedLable, '', '');
                }
                if (dataLabelSettings.intersectionAction === 'None') {
                    options = new TextOption(labelId, (textLocation.x), (textLocation.y), 'middle', text, '', '');
                }
                if (trimmedLable.length > 1) {
                    var border_1 = eventargs.border;
                    if (border_1['width'] > 1) {
                        var fill = eventargs.fill;
                        var opacity = dataLabelSettings.opacity;
                        var rx = dataLabelSettings.rx;
                        var ry = dataLabelSettings.ry;
                        var x = location['x'] - textSize['width'] / 2;
                        var y = location['y'] - textSize['height'] / 2;
                        var rectOptions = new RectOption(this.maps.element.id + '_LayerIndex_' + layerIndex + '_shapeIndex_' + index + '_rectIndex_' + index, fill, border_1, opacity, new Rect(x, y, textSize['width'], textSize['height']), rx, ry);
                        var rect = this.maps.renderer.drawRectangle(rectOptions);
                        group.appendChild(rect);
                    }
                }
                element = renderTextElement(options, style, style.color || this.maps.themeStyle.dataLabelFontColor, group);
                element.setAttribute('transform', 'translate( ' + ((location['x'] + transPoint.x) * scale) + ' '
                    + (((location['y'] + transPoint.y) * scale) + (elementSize.height / 4)) + ' )');
                group.appendChild(element);
            }
            this.dataLabelCollections.push({
                location: { x: location['x'], y: (location['y'] + elementSize.height / 4) },
                element: isNullOrUndefined(labelElement) ? element : labelElement,
                layerIndex: layerIndex,
                shapeIndex: index,
                labelIndex: index
            });
            if (labelTemplateElement.childElementCount > 0 && !this.maps.element.contains(labelTemplateElement)) {
                document.getElementById(this.maps.element.id + '_Secondary_Element').appendChild(labelTemplateElement);
            }
        }
    };
    DataLabel.prototype.getPoint = function (shapes, points) {
        shapes.map(function (current, index) {
            points.push(new Point(current['point']['x'], current['point']['y']));
        });
        return points;
    };
    /**
     * Get module name.
     */
    DataLabel.prototype.getModuleName = function () {
        return 'DataLabel';
    };
    /**
     * To destroy the layers.
     * @return {void}
     * @private
     */
    DataLabel.prototype.destroy = function (maps) {
        /**
         * Destroy method performed here
         */
    };
    return DataLabel;
}());
export { DataLabel };
